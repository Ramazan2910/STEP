ООП простыми словами:

Объектно-ориентированное программирование (ООП) в Python - это способ писать код, когда мы думаем о программе как о наборе объектов, каждый из которых имеет свои данные и умеет выполнять определенные действия.

Объекты: Мы создаем "шаблоны" для объектов, которые называются классами. Объекты - это конкретные экземпляры этих классов. Каждый объект может хранить данные и уметь выполнять определенные задачи.

Данные и действия: Объекты хранят информацию в виде данных, которые называются атрибутами. Они также могут выполнять действия, которые называются методами.

Инкапсуляция: Это механизм, позволяющий ограничить доступ к атрибутам и методам объекта извне класса. Определение атрибутов как публичных, защищенных или приватных помогает управлять доступом.
Наследование: Мы можем создавать новые классы, "наследуя" свойства и действия от существующих классов. Это позволяет нам использовать уже созданный код и добавлять к нему что-то новое.

Полиморфизм: Это позволяет объектам одного класса использовать методы другого класса, делая программу более гибкой.

ООП помогает нам писать более организованный и понятный код, разбивая его на более мелкие части (объекты) и используя их вместе для создания больших и сложных программ.


-------------------------------------------------------------------

По сложнее))

Объектно-ориентированное программирование (ООП) в Python - это подход к программированию, который базируется на использовании классов и объектов. ООП позволяет организовать код в более структурированную и модульную форму, что облегчает понимание, расширение и обслуживание программ.

В Python основные концепции ООП включают:

Классы и объекты: Класс - это шаблон, по которому создаются объекты. Объект - это экземпляр класса, имеющий свои собственные атрибуты (переменные) и методы (функции).

Атрибуты и методы: Атрибуты - это переменные, которые хранят данные объекта. Методы - это функции, которые определены внутри класса и могут работать с атрибутами объекта.

ООП (объектно-ориентированное программирование) - это парадигма программирования, которая объединяет три основных принципа:

1 - Инкапсуляция
2 - Наследование
3 - Полиморфизм

Эти принципы помогают организовать код более структурированно и упорядоченно, делая его более гибким и легко расширяемым.

Инкапсуляция: Это механизм, позволяющий ограничить доступ к атрибутам и методам объекта извне класса. Определение атрибутов как публичных, защищенных или приватных помогает управлять доступом.

Наследование: Один класс может наследовать атрибуты и методы другого класса. Наследование позволяет создавать иерархии классов и переиспользовать код.

Полиморфизм: Это способность объектов разных классов использовать одинаковые методы с различными реализациями. Это позволяет создавать более гибкие и универсальные программы.



Объекты (экземпляры) созданные из класса:

p1 = Person()
p2 = Person()
p3 = Person()

print(type(name))

--------------------------------------------------------------------------


Конкретным воплощением класса является объект.

Классы-Класс предназначен для описания некоторого типа объектов
Класс может определять переменные и константы для хранения состояния
 объекта и методы(функции) для определения поведения объекта.
 Переменные которые хранятся в классе мы будем называть полями,а функции внутри классa методами

Syntaxix:
class name_of_the_class:
    #methods
    #attributes

object = name_of_the_class()


Экземпляр класса.
Экземпляр класса - переменная представитель класса, которая присваивает ее класс и работающая от его имени.
(Если класс является планом, то экземпляр – это объект, который построен по этому плану.)

Атрибуты или поля (свойства), методы класса.
Атрибут/Поле/Свойство - Это переменная, существующая внутри объекта этого класса
и содержащая в себе значение, отражающее некоторое свойство этого объекта.

методы (функции-члены) класса – это функции, описывающие, что умеют делать объекты класса.

self – общепринятое имя для ссылки на объект,
 в контексте которого вызывается метод.
 Этот параметр обязателен и отличает метод класса от обычной функции.


Деструктор - это специальный метод классов, который выступает в качестве
метода который вызывается автоматически, как только завершается работа класса.
Обычно используется для удалению данных(освобождении памяти)
def __del__(self):


Перегрузка методов.
Если два или более метода имеют одинаковые имена,
но разное количество параметров или разные типы параметров, или и то, и другое,
то это называется перегрузкой методов.

Python является динамически типизированным языком и следовательно,
перегрузка методов здесь невозможна, тем не менее,
есть простой способ реализовать такое поведение в Python.

-------------------------------------------------------------------------------------------------------

Конструктор - это специальный метод классов, который выступает в качестве
метода который вызывается автоматически, как только создается  класса.
Обычно используется для инциализации разного рода полей.объект
def __init__(self):

__init__ в Python - это специальный метод (или конструктор), который вызывается при создании нового объекта класса. Он инициализирует (устанавливает начальные значения) атрибутов объекта.

В ООП, метод __init__ является конструктором класса. Конструктор — это специальный метод, который вызывается автоматически при создании нового экземпляра класса. Его целью обычно является инициализация начальных значений атрибутов объекта.


Пример:

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

p1 = Person("Alice", 25)
p2 = Person("Bob", 30)

print(p1.name)  # Output: Alice
print(p2.age)   # Output: 30

Здесь __init__ метод принимает два параметра name и age, и при создании объекта класса Person, эти параметры передаются в метод. Метод __init__ использует эти параметры, чтобы инициализировать атрибуты name и age каждого созданного объекта.

Таким образом, __init__ позволяет нам задать начальные значения атрибутов объекта в момент его создания.


------------------------------------------------------------------------------------------------------


self в Python - это соглашение о наименовании, используемое для ссылки на экземпляр (объект) класса внутри методов этого класса. Оно позволяет методам класса обращаться к атрибутам и другим методам этого же экземпляра.

self в Python - это параметр метода, который представляет текущий экземпляр (объект) класса. Это соглашение о наименовании, которое используется для обозначения ссылки на сам объект, к которому применяется метод.

При создании объекта на основе класса, Python автоматически передает ссылку на этот объект методам в виде параметра self. Это позволяет методам получать доступ к атрибутам и другим методам этого объекта.


Когда вы определяете метод в классе, первым параметром обычно указывается self. 

Пример 1:

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def say_hello(self):
        print(f"Hello, my name is {self.name} and I am {self.age} years old.")

p = Person("Alice", 25)
p.say_hello()  # Output: Hello, my name is Alice and I am 25 years old.


Здесь в методе say_hello используется параметр self, который ссылается на текущий экземпляр класса Person. Благодаря этому можно обращаться к атрибутам этого экземпляра, например self.name и self.age.

self позволяет методам работать с данными конкретного экземпляра класса, а не с какими-то общими данными.



Пример 2:


class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def bark(self):
        print(f"{self.name} is barking!")
    
    def introduce(self):
        print(f"I am {self.name} and I am {self.age} years old.")

dog1 = Dog("Buddy", 3)
dog2 = Dog("Max", 5)

dog1.bark()  # Output: Buddy is barking!
dog2.introduce()  # Output: I am Max and I am 5 years old.


Здесь в методах bark и introduce параметр self представляет экземпляры dog1 и dog2. Благодаря этому, методы имеют доступ к атрибутам name и age каждого из экземпляров.

Использование self позволяет методам быть обобщенными и работать с данными конкретного объекта, а не генерировать код для каждого экземпляра отдельно.



-------------------------------------------------------------------------------------------------------




ИНКАПСУЛЯЦИЯ


Инкапсуляция в Python - это механизм, который позволяет предотвратить
изменение реализованных данных внутри класса.(сторонее изменения ваших полей)

В Python есть три типа видимости: public, protected и private.

Переменные и функции, объявленные внутри класса и доступные извне, являются публичными (public).


Переменные и функции, объявленные внутри класса с использованием префикса _ (одно нижнее подчеркивание),
 являются защищенными (protected) и доступны только внутри класса и его наследников. 
 Однако, защищенные члены могут быть доступны извне, если к ним обратиться напрямую.
 
Переменные и функции, объявленные внутри класса с использованием префикса __ (двойное нижнее подчеркивание), являются приватными (private) и не доступны извне класса.

Инкапсуляция в Python - это концепция, позволяющая управлять доступом к данным и методам класса, ограничивая прямой доступ извне. Основная идея инкапсуляции заключается в том, чтобы скрыть детали реализации и предоставить интерфейс, через который можно взаимодействовать с объектом. Вот как это работает более подробно:

Приватные и защищенные атрибуты:

В Python атрибуты могут быть обозначены как публичные (доступные извне), защищенные (начинаются с одного нижнего подчеркивания) и приватные (начинаются с двух нижних подчеркиваний).
Приватные атрибуты предназначены для внутреннего использования внутри класса. Они не должны быть доступны вне класса.
Геттеры и сеттеры:

Геттеры и сеттеры - это методы, которые позволяют получать и устанавливать значения приватных атрибутов соответственно. Они предоставляют контроль над доступом к атрибутам и позволяют выполнить дополнительную логику при получении или изменении значения.
Контроль доступа:

Инкапсуляция позволяет контролировать, какие части кода могут взаимодействовать с атрибутами и методами класса. Ограничение доступа помогает избежать неправильного использования данных и поддерживает целостность объекта.

Пример:

class BankAccount:
    def __init__(self, balance):
        self.__balance = balance  # Приватный атрибут

    def get_balance(self):
        return self.__balance  # Геттер

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount

    def withdraw(self, amount):
        if amount > 0 and amount <= self.__balance:
            self.__balance -= amount

account = BankAccount(1000)
print(account.get_balance())  # Вывод: 1000
account.deposit(500)
print(account.get_balance())  # Вывод: 1500
account.withdraw(200)
print(account.get_balance())  # Вывод: 1300


В этом примере атрибут __balance является приватным, и доступ к нему осуществляется через геттер get_balance(). Это дает больший контроль над изменением баланса счета и избегает прямого изменения атрибута извне класса.


-------------------------------------------------------------------------------------------------------------



НАСЛЕДОВАНИЕ

Наследование в Python - это механизм, позволяющий создавать новый класс на основе существующего класса. Класс, который наследует функциональность, называется подклассом или дочерним классом, а класс, от которого наследуют, называется суперклассом или родительским классом. Наследование позволяет создавать иерархии классов и переиспользовать код.

Пример наследования:

class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

dog = Dog("Buddy")
print(dog.name)        # Вывод: Buddy
print(dog.speak())     # Вывод: Woof!

cat = Cat("Mittens")
print(cat.name)        # Вывод: Mittens
print(cat.speak())     # Вывод: Meow!


Здесь класс Animal является суперклассом, а классы Dog и Cat - его подклассами. Подклассы наследуют атрибуты и методы суперкласса, и при этом могут переопределять или дополнять их по своему усмотрению.

Преимущества наследования:

Повторное использование кода.
Создание иерархий классов для организации кода.
Возможность изменения или расширения функциональности существующих классов.
Наследование позволяет создавать более структурированный и легко поддерживаемый код, а также улучшает понимание взаимосвязей между классами.

Ключевые понятия и особенности наследования в Python:

Базовый (супер) класс и производный (подкласс) класс: В наследовании всегда есть два класса - суперкласс (родительский) и подкласс (дочерний). Подкласс наследует атрибуты и методы суперкласса.

Атрибуты и методы: Подкласс наследует все атрибуты и методы суперкласса, включая их атрибуты и функциональность. Он также может добавлять свои атрибуты и методы.

Переопределение методов: Подкласс может переопределять (замещать) методы суперкласса. Это позволяет подстроить поведение метода под конкретные нужды подкласса.

Иерархия наследования: Можно создавать иерархии классов, где один подкласс может наследовать от другого подкласса. Такие цепочки наследования образуют иерархию классов.

Конструкторы и инициализация: Конструкторы подкласса могут вызывать конструктор суперкласса для инициализации общих атрибутов.

Вызов методов суперкласса: Подкласс может вызывать методы суперкласса, чтобы использовать его функциональность, а затем дополнить или изменить её.

super() функция: В Python используется функция super() для доступа к методам и атрибутам суперкласса из подкласса. Это позволяет избежать дублирования кода и обеспечивает более гибкое наследование.

Множественное наследование: Python поддерживает множественное наследование, когда класс может наследовать атрибуты и методы сразу от нескольких суперклассов. Это может привести к сложностям, поэтому следует осторожно использовать.

Абстрактные классы и интерфейсы: Python поддерживает создание абстрактных классов, которые не могут быть созданы напрямую, а только наследованы. Это позволяет определить общий интерфейс для подклассов, но требует реализации методов в подклассах.



Наследование - это механизм в ООП, позволяющий создавать новый класс
на основе существующего,  уже существующий класс при этом называется базовым (или родительским)
классом, а новый класс - производным (или дочерним) классом.

При наследовании дочерний класс получает все атрибуты и методы базового класса,
а также может добавлять свои собственные атрибуты и методы,
переопределять или дополнять базовые методы.

Наследование позволяет избежать дублирования кода, если несколько классов имеют общие свойства и методы

class суперкласс :
    методы_суперкласса


class подкласс (суперкласс):
    методы_подкласса



# Множественное наследование и MRO (порядок разрешения методов).
Множественное наследование (Multiple Inheritance) - это возможность создания класса, наследующего свойства и методы одновременно от двух или более родительских классов.


 MRO (Method Resolution Order) - это порядок, в котором Python ищет методы в множественном наследовании.


----------------------------------------------------------------------------------



ПОЛИМОРФИЗМ


Полиморфизм - это один из ключевых принципов объектно-ориентированного программирования (ООП), который позволяет объектам разных классов иметь одинаковые методы, но реализованные специфичным образом для каждого класса. Простыми словами, это возможность использовать один и тот же метод для разных типов объектов.

В Python полиморфизм проявляется в следующих аспектах:

Методы с одинаковыми именами: Разные классы могут иметь методы с одинаковыми именами, но реализованными по-разному. Это позволяет вызывать один и тот же метод на объектах разных классов.

Перегрузка операторов: Python позволяет перегрузить стандартные операторы (например, +, -, *, /) для своих пользовательских классов. Это позволяет объектам разных классов использовать операторы в интуитивном контексте.

Полиморфные функции: Функции могут принимать в качестве аргументов объекты разных классов и вызывать одинаковые методы на них, даже если классы разные. Это способствует более гибкому и универсальному коду.

Преимущества полиморфизма:

Упрощение кода: Общие операции могут быть реализованы один раз для разных классов, что упрощает код и уменьшает его дублирование.
Гибкость: Можно легко добавлять новые классы с схожими методами и использовать их в существующем коде.
Обобщенность: Полиморфизм позволяет создавать обобщенные алгоритмы и функции, которые работают с разными типами данных.

Пример:

class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

def animal_sound(animal):
    return animal.speak()

dog = Dog()
cat = Cat()

print(animal_sound(dog))  # Output: "Woof!"
print(animal_sound(cat))  # Output: "Meow!"


Здесь функция animal_sound может принимать объекты разных классов и вызывать метод speak на каждом из них, возвращая различные звуки в зависимости от типа объекта.


------------------------------------------------------------------------
Magic-методы:

В Python имена методов, которые имеют ведущее и последующее двойное подчеркивание - называют магическими методами
Эти методы известны как dunder методы("Double Under (Underscores)")

https://habr.com/ru/post/186608/

Пример ниже приведён: 

from random import randint

class Dice:
    def __init__(self,sides = 4):
        self.dice_sides = sides

    def __str__(self):
        return f'Dice with {self.dice_sides} sides'

    def __len__(self):
        return self.dice_sides

    def __eq__(self, other):
        return self.roll() == other.roll()

    def __ne__(self, other):
        return self.roll != other.roll()

    def __lt__(self, other):
        return self.roll() < other.roll()

    def __le__(self, other):
        return self.roll() <= other.roll()

    def __gt__(self, other):
        return self.roll() > other.roll()

    def __ge__(self, other):
        return self.roll() >= other.roll()

    def __add__(self, other):
       return Dice(self.dice_sides + other.dice_sides)


    def __sub__(self, other):
        return Dice(self.dice_sides - other.dice_sides)

    def roll(self):
        return randint(1,self.dice_sides+1)

    def __del__(self):
        del self.dice_sides

d4 = Dice()
d12 = Dice(12)

print(d4)
print(d12)

print(len(d12))

d16 = d4 + d12
d8 = d12 - d4

print(d16 > d8)
print(d16 < d12)
print(d16 >= d4)
print(d12 != d4)
print(d12 <= d4)


print(d16)
print(d12)
print(type(d16))
print(type(d12))

-------------------------------------------------------------------------------------------------




====================================================================




Примеры кодов для изучения:


class User:

    def AddName(self,fname):
        self.name = fname

    def AddAge(self,fage):
        self.age = fage

    def Info(self):
        print(f"{self.name} and {self.age}")

    def PlusAge(self,fcislo):
        return self.age + fcislo

user1 = User()
user1.AddName("Tamerlan")
user1.AddAge(27)
user1.Info()
print(user1.PlusAge(2))

-----------------------------------------------------------------

#
#
#
#
#
#
#
#
# def CheckName(fname):
#     if fname.isnumeric():
#         return False
#     else:
#         return True
#
#
# name = input("Add name: ")
#
#
# if CheckName(name):
#     print("Registraciya uspeshno proshla! Ti chelovek!")
# else:print("Ti robot!")
#





def ShowStudents():
    global students
    for i in students:
        print(i.GetName(),i.GetSurname(),i.GetAge())


class User:
    def SetName(self,fname):
        if(self.__ChekName(fname)):
             self.__name = fname
        else:
            self.__name = 'Ti robot!'

    def SetSurname(self,fsurname):
        self.__surname = fsurname

    def SetAge(self,fage):
        self.__age = fage

    def SetSubject(self,fsubject):
        self.__subject = fsubject


    def __ChekName(self,fname):
        if fname.isnumeric():
            return False
        else:
            return True





    def GetName(self):
        return self.__name

    def GetSurname(self):
        return self.__surname

    def GetAge(self):
        return self.__age

    def GetSubject(self):
        return self.__subject

students = []

user1 = User()
user1.SetName("Qleb")
user1.SetSurname("Demonov")
user1.SetAge(15)
user1.SetSubject("Python")

students.append(user1)

user2 = User()
user2.SetName("123")
user2.SetSurname("Badalzade")
user2.SetAge(15)
user2.SetSubject("Python")

students.append(user2)

user3 = User()
user3.SetName("Ayan")
user3.SetSurname("Kerimova")
user3.SetAge(14)
user3.SetSubject("Python")


students.append(user3)
ShowStudents()
print("================================================")


#ShowStudents()


------------------------------------------------------------------



class Person:
    def __init__(self,fname,fsurname,fage,fposition):
        self.__name = fname
        self.__surname = fsurname
        self.__age = fage
        self.__position = fposition

    def GetName(self):
        return self.__name

    def GetSurname(self):
        return self.__surname

    def GetAge(self):
        return self.__age

    def GetPosition(self):
        return self.__position

    def Info(self):
        print(f"{self.__name} {self.__surname} {self.__age} {self.__position}")


class Student(Person):
    def __init__(self, fname, fsurname, fage, fposition,fhomework):
        super().__init__(fname, fsurname, fage, fposition)
        self.__homework = fhomework

    def SendHomework(self):
        print(f"{super().GetName()}  otpravil(a) {self.__homework}")


class Teacher(Person):
    def __init__(self, fname, fsurname, fage, fposition):
        super().__init__(fname, fsurname, fage, fposition)

    def CheckHomework(self,fnameStudent,fgrade):
        print(f"{super().GetName()} ocenil(a) {fnameStudent} domashnee zadanie na {fgrade} ballov")



class Manager(Person):
    def __init__(self, fname, fsurname, fage, fposition):
        super().__init__(fname, fsurname, fage, fposition)

    def MailToParents(self,fnameStudent,fcomment):
        print(f"{super().GetName()} comment {fnameStudent}: {fcomment}")



person1 = Student("Gleb","Demonov",15,"Student","Lesson 28")
person1.SendHomework()

person2 = Student("Ayan","Kerimova",15,"Student","Lesson 44")
person2.SendHomework()


person3 = Teacher("Tamerlan","Hasanov",27,"Teacher")
person3.CheckHomework(person2.GetName(),12)



person4 = Manager("Fidan","Kerimova",22,"Manager")
person4.Info()
person4.MailToParents(person1.GetName(),"Domashneyee zadanie vo  vrema ne vipolnaet postoyanno kormit zavtrakami (toest zavtra sdelayu) Proshu primite eto v svedenii i ne  davayte dengi na karmannie rasxodi, pust zarabativaet sam!")



-------------------------------------------------------------------------------------------------------------------------------------

class Student:

    def SetName(self,_name):
        self.__name = _name

    def SetSurname(self,_surname):
        self.__surname = _surname

    def SetAge(self,_age):
        self.__age = _age

    def SetLogin(self,_login):
        self.__login = _login

    def SetPassword(self,_password):
        self.__password = _password

    def GetLogin(self):
        return self.__login

    def GetPassword(self):
        return self.__password

    def GetInfo(self):
        print(f"{self.__name} {self.__surname}")

    def setBirthYear(self, birthYear):
        if birthYear >= 1950 and birthYear <= 2020:
            self.__birthYear = birthYear
            return True
        raise Exception("Год рождения должен быть между 1950 и 2023.")
    def GetAge(self):
        print(self.__birthYear)

    def SendHomework(self,_homework):
        self.__homework = _homework
        print("Tapshiriqi gonderdim")


user1 = Student()
user1.SetName("Tamerlan")
user1.SetSurname("Hasanov")
user1.SetLogin("Tamerlan124")
user1.SetPassword("Tamerlan@124")

user1.GetInfo()

year = 2050
if year > 1950 and year < 2021:
    user1.setBirthYear(year)
    user1.GetAge()
else:
    print("Возраст не подходит")

loginiAdd = input("Логин: ")
if loginiAdd == user1.GetLogin():

else:
    print("Ошибка")

------------------------------------------------------------

Наследование: 

class Person:
    def __init__(self,name,surname,age):
        self.__name = name
        self.__surname = surname
        self.__age = age

    def getAge(self):
        return self.__age

    def getName(self):
        return self.__name

    def getSurname(self):
        return self.__surname

class Student(Person):
    def __init__(self,name,surname,age,fhomeWork):
        super().__init__(name,surname,age)
        self.__homeWork = fhomeWork

    def getHomework(self):
        return self.__homeWork



class Employee(Person):
    def __init__(self,name,surname,age):
        super().__init__(name,surname,age)

    def CheckHomeWork(self,fhomeWork):
        print( f"{super().getName()} {fhomeWork} проверил задание.")



homeWork = "main.py"

student1 = Student("Tamerlan", "Hasanov",26,homeWork)

employee1 = Employee("Rauf","Alizade", 42)

employee1.CheckHomeWork(student1.getHomework())

-----------------------------------------------------------------------









