В программировании использование функций предоставляет следующие преимущества:

■ Функции позволяют выполнять один и тот же код несколько раз без повторения строк кода.
■ Функции разбивают длинные программы на более мелкие компоненты, что упрощает чтение кода и делает логику алгоритма более понятной.
■ Функции могут быть поделены и использованы другими программистами (в этом случае другой программист может использовать эти функции как "черный ящик" для решения определенной задачи, не задумываясь о том, как они созданы).

Функции способствуют разделению вашей программы на части, структурированию ее и обеспечивают эффективное повторное использование кода.

Функции нужны для того, чтобы не повторять какую-то часть кода
по несколько раз, чтобы не заполнить ОЗУ и не делать ваш код сложно-читаемым

Определение функции: Функцию определяют с помощью ключевого слова def, за которым следует имя функции и скобки. Внутри скобок можно указать параметры, которые функция будет принимать.

def Message(name):
    print("Hello, " + name)

Вызов функции: Для вызова функции используется её имя, за которым следуют скобки с аргументами (если есть).

Message("Alice")

Возвращение значения: Функция может возвращать значение с помощью ключевого слова return. Если return не указано, функция вернет None.

def add(a, b):
    return a + b



#	Встроенные функции.
'''
max()
min()
len()
reversed()
sorted()
int() 
float()
str()
bool()
print()
len()

sum()
eval() - преобразовывает строчное выражение в математическое и выдает значение,
 которое является результатом какой-либо матем-ой операции
pow()
ord() - переводил в его десятичное представление по аски
oct() - 8
bin() - 2
hex() - 16
abs() - модуль
fabs() - int module

map()
filter()
zip()
reduce()


#	Математические функции и случайные числа.
'''
import math
import random


Виды функций:
1) ничего не принимает ничего не возвращает
2) при входе принимает но ничего не возвращает
3) ничего не принимает но возвращает
4) принимает и возвращает

Ничего не принимает ничего не возвращает:

def Foo():
    print("Hello World")
    
Foo()


При входе принимает но ничего не возвращает:

def Foo(message):
    print(message)

Foo("Hello World")


Ничего не принимает но возвращает:

def Foo():
    return "Hello World!"

a = Foo()
print(a)


Принимает и возвращает:

def Foo(num1,num2):
    return num1 + num2

a = Foo(5,4)
print(a)


global - для перевода локальной переменной в глобальную

Функциональное программирование - это подход к программированию, при котором программа представляется в виде набора функций, которые выполняют отдельные шаги алгоритма программы во время её выполнения.

Мы используем принцип функционального программирования в Python, предоставляя нам множество встроенных функций.

Этот подход позволяет писать более чистый и модульный код, где каждая функция выполняет конкретную задачу. Такой код легче понимать, тестировать и поддерживать. В функциональном программировании функции считаются "первоклассными объектами", что означает, что их можно передавать как аргументы в другие функции, возвращать из функций и присваивать переменным.

Примеры функциональных концепций в Python включают встроенные функции, такие как map(), filter(), reduce(), lambda (анонимные функции) и генераторы. Эти инструменты позволяют более эффективно работать с коллекциями данных, применяя операции к каждому элементу.

В итоге, функциональное программирование помогает создавать более абстрактный, модульный и легко понимаемый код, что способствует его качеству и удобству обслуживания.


Основное отличие между процедурным и функциональным программированием заключается в том, как они организуют код и управляют данными. Процедурное программирование ориентировано на процедуры (функции), которые могут изменять глобальные переменные, а функциональное программирование способствует созданию функций, которые не имеют побочных эффектов и работают с данными через передачу аргументов и возврат результатов.



Пример 1:

Пример процедурного программирования:

# Процедурный код
def calculate_average(numbers):
    total = 0
    count = 0
    for num in numbers:
        total += num
        count += 1
    return total / count

scores = [85, 90, 78, 92, 88]
average_score = calculate_average(scores)
print("Средний балл:", average_score)


Здесь процедурный код использует цикл и изменяемые переменные total и count для вычисления среднего балла на основе списка оценок.

Пример функционального программирования:


# Функциональный код
def calculate_average(numbers):
    return sum(numbers) / len(numbers)

scores = [85, 90, 78, 92, 88]
average_score = calculate_average(scores)
print("Средний балл:", average_score)

В функциональном коде используется функция sum для вычисления суммы оценок и функция len для определения количества оценок в списке. Функциональный подход делает код более кратким и читаемым, а также избегает изменения глобальных переменных.




Пример 2:

# Процедурный код
def square_and_add(a, b):
    a_squared = a * a
    b_squared = b * b
    result = a_squared + b_squared
    return result

num1 = 3
num2 = 4
result = square_and_add(num1, num2)
print("Результат:", result)


В этом процедурном коде функция square_and_add берет два числа, возводит их в квадрат и затем складывает результаты.

Пример функционального программирования на Python:

# Функциональный код
def square(x):
    return x * x

def add(x, y):
    return x + y

num1 = 3
num2 = 4

result = add(square(num1), square(num2))
print("Результат:", result)

В этом функциональном коде используются две отдельные функции square и add, каждая из которых выполняет одну операцию. Операции комбинируются последовательно для получения конечного результата. Функциональный подход ориентирован на создание маленьких, чистых функций, которые могут быть комбинированы для выполнения сложных задач.



Пример 3:

Пример процедурного программирования на Python:

# Процедурный код
def greet(name):
    print("Привет, " + name + "!")

user_name = "Алиса"
greet(user_name)


В этом процедурном коде функция greet просто выводит приветствие на экран с использованием имени пользователя.

Пример функционального программирования на Python:

# Функциональный код
def greet(name):
    return "Привет, " + name + "!"

user_name = "Алиса"
greeting = greet(user_name)
print(greeting)

В этом функциональном коде функция greet возвращает приветствие вместо того, чтобы непосредственно его выводить. Затем результат этой функции сохраняется в переменной greeting и выводится на экран.





Лямбда-функции - это анонимные функции, которые определяются без использования идентификатора и объявляются непосредственно в месте их использования. Они широко используются во многих языках программирования. Однако синтаксис для них может сильно отличаться от языка к языку. Выражение "lambda" служит синтаксическим элементом для определения анонимной функции.

message = lambda: print("hello")

message()  # hello
------

sum = lambda a, b: a + b

print(sum(4, 5))  # 9
---------

def select_operation(choice):
    if choice == 1:
        return lambda a, b: a + b
    elif choice == 2:
        return lambda a, b: a - b
    else:
        return lambda a, b: a * b


operation = select_operation(1)  # operation = sum
print(operation(4, 5))  

operation = select_operation(2)  # operation = subtract
print(operation(4, 5))  

operation = select_operation(3)  # operation = multiply
print(operation(15, 3))  


--------------------------------------

■ Лямбда-выражения записываются в одну строку (если выражение будет размещено на второй строке, это вызовет ошибку).
■ Лямбда-функции создают анонимные функции, которым можно не присваивать имя переменной (как в примере выше) или использовать прямо на месте создания (анонимные функции).
■ Результатом лямбда-функции является только выражение, которое возвращает значение, созданное только лямбда-функцией. Для этого не требуется использование ключевого слова return.
■ Лямбда-функции используются для реализации простых фрагментов кода (вычислений) из обычных функций.

Из-за того, что лямбда-функции являются выражениями, их можно применять в местах, где использование оператора def не разрешено, таких как литералы или вызовы функций.

Обратите внимание, что лямбда-функции следует использовать там, где это удобно и понятно, а избыточное использование может ухудшить читаемость кода.



def Foo(*args):
    a = args[4]
    print(a)
    print(args)


Foo(4,5,7,"Tom","Fred")

===================================================

Распаковка 
Мы можем использовать * для распаковки списка, чтобы все его элементы можно было передавать как разные параметры.

Распаковка в функциях Python связана с передачей аргументов функции в виде распакованных коллекций, таких как списки или кортежи. Это позволяет передавать переменное количество аргументов в функцию, а также удобно работать с функциями, ожидающими несколько аргументов.

Упаковка (packing) в Python относится к процессу сборки нескольких значений в один объект. Обычно это применяется к последовательностям данных, таким как списки или кортежи. 

Упаковка 
Когда мы не знаем, сколько аргументов нужно передать функции


Упаковка именованных аргументов функции в словарь с использованием **kwargs:

def print_kwargs(**kwargs):
    print(kwargs)

print_kwargs(name="Alice", age=30)  # Вывод: {'name': 'Alice', 'age': 30}



# Упаковка

def calc(*args):
    summ = 0
    for i in args:
        summ += i

    print(summ)
    print(type(args))

calc(1, 2, 3)
calc(1, 2, 3, 4, 4,5)


def calc(*args):

    print(args)
    print(type(args))

calc(1, 2, 3)
calc(1, 2, 3, "Tom",True)


#Распаковка
def calc(a,b,c,d,e):
    return a+b+c+d+e

list_el = [1,2,3,4,5]
print(calc(*list_el))


Аргументы по умолчанию, аргументы-ключи.


def user(name,  surname="Mammadov"):
    return f'Hello {name} {surname}'

print(user("Tamerlan","Hasanov"))
print(user("Tamerlan"))


Рекурсия в программировании означает использование функцией самой себя для решения задачи. В Python и других языках программирования рекурсия может быть мощным инструментом для решения определенных задач, но она также требует осторожного подхода, чтобы избежать бесконечной рекурсии и переполнения стека вызовов.

Пример простой рекурсивной функции в Python:


def Factorial(n):
    if n == 0:
        return 1
    else:
        return n * Factorial(n - 1)

print(Factorial(5))


В этом примере функция factorial рассчитывает факториал числа n. Если n равно 0, функция возвращает 1 (базовый случай). В противном случае, функция вызывает саму себя с аргументом n - 1 и умножает результат на текущее значение n.

Рекурсия обычно используется в следующих случаях:

Задачи, которые могут быть разбиты на подзадачи того же типа. Примеры включают вычисление факториала, вычисление чисел Фибоначчи и т.д.

Обход структур данных, таких как деревья и связанные списки.

Решение задачи, когда вам необходимо рассмотреть все возможные комбинации или варианты.

Важно учитывать, что рекурсия может быть требовательной к памяти и производительности, особенно для больших задач. Также важно обеспечивать условие выхода из рекурсии (базовый случай), чтобы избежать бесконечной рекурсии.

При использовании рекурсии необходимо следить за тем, чтобы каждый следующий вызов функции приближался к базовому случаю, иначе рекурсия будет продолжаться бесконечно.


Ещё упрощенный вариант рекурсии:

Рассмотрим функцию, которая выводит числа от 1 до заданного числа:

def count_up(n):
    if n <= 0:
        return
    count_up(n - 1)  # Рекурсивный вызов с аргументом на 1 меньше
    print(n)

count_up(5)

Как это работает:

Функция count_up принимает аргумент n.
В базовом случае, когда n меньше или равно 0, функция ничего не делает и просто завершается (return).
В рекурсивном случае, если n больше 0, функция вызывает саму себя с аргументом n - 1, уменьшая n на 1.
После этого, функция выводит значение n.
Когда мы вызываем count_up(5), происходит следующее:

count_up(5) вызывает count_up(4)
count_up(4) вызывает count_up(3)
count_up(3) вызывает count_up(2)
count_up(2) вызывает count_up(1)
count_up(1) вызывает count_up(0)
count_up(0) завершает выполнение
Таким образом, числа выводятся в порядке от 1 до 5. Это пример рекурсии, где функция вызывает саму себя для решения более мелких задач.

def countdown(n):
    if n <= 0:
        print("Boom!")
    else:
        print(n)
        countdown(n - 1)

countdown(3)

Когда вы вызываете countdown(3), это приводит к следующему:

Выводится число 3, потому что n равно 3.
Вызывается countdown(2):
Выводится число 2, потому что n равно 2.
Вызывается countdown(1):
Выводится число 1, потому что n равно 1.
Вызывается countdown(0):
Выводится "Boom!", потому что n меньше или равно 0.
Таким образом, числа выводятся в обратном порядке от 3 до 1, а затем выводится "Boom!".


# reduce()- когда требуется обработать список значений таким образом, чтобы свести процесс к единственному результату,

from functools import reduce

def Foo(a,b):
    return a + b

ls = [1, 2, 3, 4, 5]
result = reduce(Foo, ls)

print(result)



# map() - позволяет обрабатывать одну или несколько последовательностей с использованием заданной функции.


def Foo(a):
    return a + 10

ls = [1, 2, 3, 4, 5]
result = list(map(Foo, ls))

print(result)


# filter()- определяет нужно ли исключить конкретный элемент из последовательности или нет(если да  то фильтрует последовательность, если нет ничего не делает)


def Foo(a):
    if a > 3:
        return a

ls = [1, 2, 3, 4, 5,6,7,8,9]
result = list(filter(Foo, ls))

print(result)






