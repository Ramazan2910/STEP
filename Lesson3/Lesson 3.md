# Тема урока: DDL 
- Создание базы данных
- Создание таблицы
- Первичный ключ
- - Автоинкремент
- - кластеризированный индекс
- - не кластеризированный индекс
- Ограничения(constraints)

`DDL` - Data Definition Language - язык определения данных.

На самом деле мы можем создавать таблицы в нашей БД, а как мы знаем наша БД состоит
из таблиц, с помощью графического интерфейса в `SSMS`

Но это неудобно и при изменении очень много конфликтов. Вам нужно научиться 
создавать таблицы с помощью `DDL` запросов.

В синтаксис `DDL` входят следующие команды:

- `CREATE` - создание объектов
- `ALTER` - изменение объектов
- `DROP` - удаление объектов
- `TRUNCATE` - очистка таблицы

Давайте создадим базу данных Academy и таблицу Students

В таблице Students будут следующие столбцы(columns):
1. `Id` - тип данных `int` - первичный ключ
2. `Name` - тип данных `nvarchar(50)` - имя студента
3. `Surname` - тип данных `nvarchar(50)` - фамилия студента
4. `Email` - тип данных `nvarchar(50)` - почта студента
5. `BirthDate` - тип данных `date` - дата рождения студента

```sql

@IF NOT EXISTS(SELECT * FROM sys.databases WHERE name = 'Academy')
    CREATE DATABASE Academy
   
GO

```

Код выше проверяет существует ли база данных Academy, если нет, то создает ее.

`GO` -  нужен для того чтобы разделять части кода друг от друга, 
он не является частью `T-SQL` и не обязателен.

```sql

USE Academy 

CREATE Table Students
(
    [Id] int identity(1, 1) PRIMARY KEY,
    [Name] nvarchar(50) NOT NULL,
    [Surname] nvarchar(50) NOT NULL,
    [Email] nvarchar(50) NOT NULL UNIQUE,
    [BirthDate] date 
);

```

`USE Academy` - указывает на то что мы будем работать с базой данных Academy
по умолчанию `T-SQL` работает с базой данных `master`, так что рано или поздно 
вы забудете про `USE` и создадите таблицу в `master` базе данных. 

`CREATE DATABASE Students` - создает таблицу Students

Id, Name, Surname, Email, BirthDate - это названия столбцов. Я написал их в брэкетах
потому что `Name` например это еще и ключевое слово. Чтобы не было конфликтов я написал так.

`int` - это тип данных, в данном случае это целое число
`nvarchar(50)` - это тип данных, в данном случае это строка, 50 - это максимальная длина строки
`date` - это тип данных, в данном случае это дата

`identity(1, 1)` - это автоинкремент, первое число это начальное значение, второе шаг

`PRIMARY KEY` - это первичный ключ, это уникальное значение в таблице
`NOT NULL` - это означает что значение не может быть пустым
`UNIQUE` - это означает что значение должно быть уникальным

## Первичный ключ (Primary Key)

Первичный ключ это уникальное значение в таблице, его нельзя повторять.
При его создании можно использовать `identity` для автоинкремента, если он типа данных 
`int` или `bigint`.

При этом очень важно знать что автоматически при создании `primary key` создается 
кластеризированный индекс.



## Кластеризированный индекс (Clustered Index)

Кластеризированный индекс это индекс который сортирует данные в таблице по ключу. 
Он работает по принципу B-Tree, это значит что данные хранятся в виде дерева. Сам кластеризированный
индекс делится на страницы, каждая страница хранит ссылку на следующую страницу `Вес каждой страницы 8 КВ`.

Индекс состоит из 3 частей. 
1. Root - корень дерева
2. Intermediate - промежуточные узлы
3. Leaf - листья

Вот иллюстрация как это работает:

![](https://josipmisko.com/img/clustered-vs-nonclustered-index.webp)

Такие данные автоматически сортируются по ключу, что значит что вы не можете создать два одинаковых ключа.

## Не кластеризированный индекс (Non-Clustered Index)

Он создается при создании индекса вручную или же если вы используете например `UNIQUE` или `FOREIGN KEY`(объясню потом).

В отличии от кластеризированного индекса, не кластеризированный индекс не сортирует данные в таблице, что ускоряет поиск
не в O(1), а в O(log n).ч   

## Ограничения (Constraints)

Ограничения это правила которые накладываются на столбцы таблицы. Они могут быть разные:
1. Условие `NOT NULL` - это означает что значение не может быть пустым
2. Условие `UNIQUE` - это означает что значение должно быть уникальным
3. Условие `CHECK` - это означает что значение должно соответствовать условию
4. Условие `DEFAULT` - это означает что значение по умолчанию

`При создании ограничения автоматически создается и не кластеризированный индекс`

К примеру давайте видоизменим таблицу Students и добавим ограничения

```sql
USE Academy 

CREATE Table Students
(
    [Id] int identity(1, 1) PRIMARY KEY,
    [Name] nvarchar(50) NOT NULL CHECK (LEN([Name]) >= 2),
    [Surname] nvarchar(50) NOT NULL CHECK (LEN([Surname]) >= 2),
    [Email] nvarchar(50) NOT NULL UNIQUE CHECK (Email LIKE '%@%.%'),
    [Age] int DEFAULT 18 CHECK (Age >= 18),
    [BirthDate] date 
);

```


